//! {{project-name}} - A rustbridge plugin{% if completed %} demonstrating regex matching with LRU caching{% endif %}

{% if completed -%}
use lru::LruCache;
use regex::Regex;
{%- endif %}
use rustbridge::prelude::*;
use rustbridge::{serde_json, tracing};
{% if completed -%}
use std::num::NonZeroUsize;
use std::sync::Mutex;
{%- endif %}

// ============================================================================
// Message Types
// ============================================================================
{% if completed %}
/// Regex match request message
#[derive(Debug, Clone, Serialize, Deserialize, Message)]
#[message(tag = "match")]
pub struct MatchRequest {
    /// The regex pattern to match against
    pub pattern: String,
    /// The text to test
    pub text: String,
}

/// Regex match response message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MatchResponse {
    /// Whether the pattern matched the text
    pub matches: bool,
    /// Whether the pattern was retrieved from cache
    pub cached: bool,
}

// ============================================================================
// Plugin Configuration
// ============================================================================

/// Plugin configuration data (parsed from config.data JSON)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginConfigData {
    /// Maximum number of compiled regex patterns to cache
    pub cache_size: usize,
}

impl Default for PluginConfigData {
    fn default() -> Self {
        Self { cache_size: 100 }
    }
}
{% else %}
/// Echo request message
#[derive(Debug, Clone, Serialize, Deserialize, Message)]
#[message(tag = "echo")]
pub struct EchoRequest {
    pub message: String,
}

/// Echo response message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EchoResponse {
    pub message: String,
    pub length: usize,
}
{% endif %}
// ============================================================================
// Plugin Implementation
// ============================================================================
{% if completed %}
const DEFAULT_CACHE_SIZE: usize = 100;

/// Regex plugin with configurable LRU caching
pub struct {{project-name | pascal_case}} {
    /// LRU cache of compiled regexes (pattern -> Regex)
    cache: Mutex<LruCache<String, Regex>>,
    /// The configured cache size (for logging)
    cache_size: usize,
}

impl Default for {{project-name | pascal_case}} {
    fn default() -> Self {
        let cache_size = NonZeroUsize::new(DEFAULT_CACHE_SIZE).expect("default is non-zero");
        Self {
            cache: Mutex::new(LruCache::new(cache_size)),
            cache_size: cache_size.get(),
        }
    }
}

impl PluginFactory for {{project-name | pascal_case}} {
    /// Called when config.data contains JSON configuration
    fn create_configured(config: &PluginConfig) -> PluginResult<Self> {
        // Parse the configuration
        let config_data: PluginConfigData = serde_json::from_value(config.data.clone())?;

        // Handle invalid cache size gracefully
        let cache_size = NonZeroUsize::new(config_data.cache_size)
            .unwrap_or_else(|| NonZeroUsize::new(DEFAULT_CACHE_SIZE).expect("default is non-zero"));

        tracing::info!(
            cache_size = cache_size.get(),
            "Creating regex plugin with custom configuration"
        );

        Ok(Self {
            cache: Mutex::new(LruCache::new(cache_size)),
            cache_size: cache_size.get(),
        })
    }
}

#[async_trait]
impl Plugin for {{project-name | pascal_case}} {
    async fn on_start(&self, _ctx: &PluginContext) -> PluginResult<()> {
        tracing::info!(cache_size = self.cache_size, "{{project-name}} started");
        Ok(())
    }

    async fn handle_request(
        &self,
        _ctx: &PluginContext,
        type_tag: &str,
        payload: &[u8],
    ) -> PluginResult<Vec<u8>> {
        match type_tag {
            "match" => {
                let req: MatchRequest = serde_json::from_slice(payload)?;

                tracing::debug!(
                    pattern = %req.pattern,
                    text_len = req.text.len(),
                    "Processing match request"
                );

                let mut cache = self.cache.lock().expect("cache lock poisoned");

                let (regex, cached) = if let Some(regex) = cache.get(&req.pattern) {
                    (regex, true)
                } else {
                    let regex = Regex::new(&req.pattern).map_err(|e| {
                        tracing::warn!(
                            pattern = %req.pattern,
                            error = %e,
                            "Invalid regex pattern"
                        );
                        PluginError::HandlerError(format!("Invalid regex pattern: {}", e))
                    })?;
                    cache.put(req.pattern.clone(), regex);
                    (cache.get(&req.pattern).expect("just inserted"), false)
                };

                let matches = regex.is_match(&req.text);

                tracing::debug!(
                    pattern = %req.pattern,
                    matches,
                    cached,
                    "Match completed"
                );

                let response = MatchResponse { matches, cached };
                Ok(serde_json::to_vec(&response)?)
            }
            _ => Err(PluginError::UnknownMessageType(type_tag.to_string())),
        }
    }

    async fn on_stop(&self, _ctx: &PluginContext) -> PluginResult<()> {
        let cache = self.cache.lock().expect("cache lock poisoned");
        tracing::info!(cached_patterns = cache.len(), "{{project-name}} stopped");
        Ok(())
    }

    fn supported_types(&self) -> Vec<&'static str> {
        vec!["match"]
    }
}

// ============================================================================
// FFI Entry Point
// ============================================================================

// Generate FFI entry point - uses PluginFactory::create()
rustbridge_entry!({{project-name | pascal_case}}::create);
pub use rustbridge::ffi_exports::*;

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
#[allow(non_snake_case)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn create___with_null_config___uses_default_cache_size() {
        let config = PluginConfig::default(); // data is Value::Null

        let plugin = {{project-name | pascal_case}}::create(&config).unwrap();

        assert_eq!(plugin.cache_size, DEFAULT_CACHE_SIZE);
    }

    #[tokio::test]
    async fn create___with_custom_config___uses_configured_cache_size() {
        let config_data = PluginConfigData { cache_size: 50 };
        let config = PluginConfig {
            data: serde_json::to_value(config_data).unwrap(),
            ..Default::default()
        };

        let plugin = {{project-name | pascal_case}}::create(&config).unwrap();

        assert_eq!(plugin.cache_size, 50);
    }

    #[tokio::test]
    async fn create___with_zero_cache_size___uses_default() {
        let config_data = PluginConfigData { cache_size: 0 }; // Invalid!
        let config = PluginConfig {
            data: serde_json::to_value(config_data).unwrap(),
            ..Default::default()
        };

        let plugin = {{project-name | pascal_case}}::create(&config).unwrap();

        // Zero is invalid for NonZeroUsize, so we fall back to default
        assert_eq!(plugin.cache_size, DEFAULT_CACHE_SIZE);
    }

    #[tokio::test]
    async fn handle_request___first_request___not_cached() {
        let plugin = {{project-name | pascal_case}}::default();
        let ctx = PluginContext::new(PluginConfig::default());

        let request = serde_json::to_vec(&MatchRequest {
            pattern: r"\d+".to_string(),
            text: "test123".to_string(),
        })
        .unwrap();

        let response = plugin
            .handle_request(&ctx, "match", &request)
            .await
            .unwrap();
        let match_response: MatchResponse = serde_json::from_slice(&response).unwrap();

        assert!(match_response.matches);
        assert!(!match_response.cached); // First time, not cached
    }

    #[tokio::test]
    async fn handle_request___same_pattern_twice___second_is_cached() {
        let plugin = {{project-name | pascal_case}}::default();
        let ctx = PluginContext::new(PluginConfig::default());

        // First request
        let request = serde_json::to_vec(&MatchRequest {
            pattern: r"\d+".to_string(),
            text: "test123".to_string(),
        })
        .unwrap();

        let _ = plugin
            .handle_request(&ctx, "match", &request)
            .await
            .unwrap();

        // Second request with same pattern
        let request = serde_json::to_vec(&MatchRequest {
            pattern: r"\d+".to_string(),
            text: "456".to_string(),
        })
        .unwrap();

        let response = plugin
            .handle_request(&ctx, "match", &request)
            .await
            .unwrap();
        let match_response: MatchResponse = serde_json::from_slice(&response).unwrap();

        assert!(match_response.matches);
        assert!(match_response.cached); // Second time, from cache!
    }

    #[tokio::test]
    async fn handle_request___invalid_regex___returns_error() {
        let plugin = {{project-name | pascal_case}}::default();
        let ctx = PluginContext::new(PluginConfig::default());

        let request = serde_json::to_vec(&MatchRequest {
            pattern: r"[invalid".to_string(), // Unclosed bracket
            text: "test".to_string(),
        })
        .unwrap();

        let result = plugin.handle_request(&ctx, "match", &request).await;

        assert!(result.is_err());
    }
}
{% else %}
/// Plugin implementation
#[derive(Default)]
pub struct {{project-name | pascal_case}};

#[async_trait]
impl Plugin for {{project-name | pascal_case}} {
    async fn on_start(&self, _ctx: &PluginContext) -> PluginResult<()> {
        tracing::info!("{{project-name}} started");
        Ok(())
    }

    async fn handle_request(
        &self,
        _ctx: &PluginContext,
        type_tag: &str,
        payload: &[u8],
    ) -> PluginResult<Vec<u8>> {
        match type_tag {
            "echo" => {
                let req: EchoRequest = serde_json::from_slice(payload)?;
                let response = EchoResponse {
                    length: req.message.len(),
                    message: req.message,
                };
                Ok(serde_json::to_vec(&response)?)
            }
            _ => Err(PluginError::UnknownMessageType(type_tag.to_string())),
        }
    }

    async fn on_stop(&self, _ctx: &PluginContext) -> PluginResult<()> {
        tracing::info!("{{project-name}} stopped");
        Ok(())
    }

    fn supported_types(&self) -> Vec<&'static str> {
        vec!["echo"]
    }
}

// ============================================================================
// FFI Entry Point
// ============================================================================

// Generate FFI entry point
rustbridge_entry!({{project-name | pascal_case}}::default);

// Re-export FFI functions for the shared library
pub use rustbridge::ffi_exports::*;

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_echo() {
        let plugin = {{project-name | pascal_case}};
        let ctx = PluginContext::new(PluginConfig::default());

        let request = serde_json::to_vec(&EchoRequest {
            message: "Hello, World!".to_string(),
        })
        .unwrap();

        let response = plugin.handle_request(&ctx, "echo", &request).await.unwrap();
        let echo_response: EchoResponse = serde_json::from_slice(&response).unwrap();

        assert_eq!(echo_response.message, "Hello, World!");
        assert_eq!(echo_response.length, 13);
    }
}
{% endif %}
